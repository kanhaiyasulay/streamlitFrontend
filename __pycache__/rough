import streamlit as st
import time

st.set_page_config(page_title="Chatbot", page_icon="ğŸ’¬", layout="wide")

# --- Floating input + WhatsApp-like bubbles ---
st.markdown(
    """
    <style>
    :root {
        --chat-input-height: 88px;
        --chat-input-width: min(820px, 92vw);
        --bubble-max-width: 78%;
        --user-bg: #d7eaff;
        --bot-bg: #f0f0f0;
        --user-text: #111;
        --bot-text: #111;
    }

    section[data-testid="stSidebar"] h1 { font-size: 22px !important; }

    .main .block-container {
        padding-bottom: var(--chat-input-height) !important;
    }

    div[data-testid="stChatInput"] {
        position: fixed !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        bottom: 0.5rem !important;
        width: var(--chat-input-width) !important;
        z-index: 1000 !important;
        background: rgba(250, 250, 250, 0.85);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(49, 51, 63, 0.15);
        box-shadow: 0 10px 30px rgba(0,0,0,0.12);
        border-radius: 16px;
        padding: 0.4rem 0.6rem;
    }

    div[data-testid="stChatInput"] textarea {
        min-height: 46px !important;
        padding: 12px 14px !important;
        border-radius: 12px !important;
    }

    .chat-wrap {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
    }

    .msg-row {
        display: flex;
        width: 100%;
        margin-bottom: 1.6rem;
    }

    .msg-row.left  { justify-content: flex-start; }
    .msg-row.right { justify-content: flex-end; }

    .bubble {
        max-width: var(--bubble-max-width);
        padding: 8px 12px;
        border-radius: 14px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.06);
        line-height: 1.45;
        word-wrap: break-word;
        white-space: pre-wrap;
        font-size: 0.96rem;
        position: relative;
    }

    .bubble.user {
        background: var(--user-bg);
        color: var(--user-text);
        border-top-right-radius: 6px;
    }

    .bubble.assistant {
        background: var(--bot-bg);
        color: var(--bot-text);
        border-top-left-radius: 6px;
    }

    .bubble.user:after {
        content: "";
        position: absolute;
        right: -4px;
        top: 8px;
        width: 8px; height: 8px;
        background: var(--user-bg);
        transform: rotate(45deg);
    }

    .bubble.assistant:after {
        content: "";
        position: absolute;
        left: -4px;
        top: 8px;
        width: 8px; height: 8px;
        background: var(--bot-bg);
        transform: rotate(45deg);
    }
    </style>
    """,
    unsafe_allow_html=True
)

# -----------------------------
# Helpers
# -----------------------------

def init_state():
    if "messages" not in st.session_state:
        st.session_state.messages = [
            {"role": "assistant", "content": "Hi! I'm your FinOps assistant ğŸ’° Ask me about your cloud cost."}
        ]

def add_message(role, content):
    st.session_state.messages.append({"role": role, "content": content})

def bubble_html(role: str, content: str) -> str:
    side = "right" if role == "user" else "left"
    who  = "user" if role == "user" else "assistant"
    return f'''
    <div class="msg-row {side}">
        <div class="bubble {who}">{content}</div>
    </div>
    '''

def render_messages(container):
    with container:
        st.markdown('<div class="chat-wrap">', unsafe_allow_html=True)
        for msg in st.session_state.messages:
            st.markdown(bubble_html(msg["role"], msg["content"]), unsafe_allow_html=True)
        st.markdown('</div>', unsafe_allow_html=True)

def simple_bot_reply(user_text, temperature):
    return (
        f"### ğŸ’° Cloud Cost Analysis\n\n"
        f"Based on your query:\n\n"
        f"**{user_text}**\n\n"
        f"Here is your structured summary:\n\n"
        f"- Total Cost: â‚¹ 1,25,000\n"
        f"- Change vs Previous Period: +8%\n"
        f"- Primary Driver: Increased compute usage\n\n"
        f"_Temperature setting: {temperature}_"
    )

def generate_thinking_steps(user_text):
    text = user_text.lower()

    if "why" in text:
        return [
            "ğŸ” Understanding your question...",
            "ğŸ“Š Comparing historical cloud costs...",
            "ğŸ“ˆ Identifying cost drivers...",
            "ğŸ§® Preparing explanation..."
        ]
    elif "last" in text or "months" in text:
        return [
            "ğŸ” Understanding time range...",
            "ğŸ“… Filtering selected months...",
            "ğŸ“Š Aggregating cloud cost data...",
            "ğŸ“ˆ Preparing summary..."
        ]
    elif "forecast" in text or "predict" in text:
        return [
            "ğŸ” Understanding forecasting request...",
            "ğŸ“Š Gathering historical trends...",
            "ğŸ“ˆ Running projection model...",
            "ğŸ§® Preparing forecast summary..."
        ]
    else:
        return [
            "ğŸ” Understanding your question...",
            "ğŸ“Š Fetching relevant cloud cost data...",
            "ğŸ§® Performing analysis...",
            "ğŸ“ˆ Preparing final summary..."
        ]

# -----------------------------
# App
# -----------------------------

init_state()

with st.sidebar:
    st.header("âš™ï¸ Settings")

    temperature = st.slider(
        "Temperature",
        min_value=0.0,
        max_value=2.0,
        value=0.7,
        step=0.05,
        help="Lower = more deterministic, Higher = more creative"
    )

    if st.button("ğŸ§¹ Clear chat", use_container_width=True):
        st.session_state.messages = [
            {"role": "assistant", "content": "Chat cleared âœ… Start again!"}
        ]
        st.rerun()

st.title("ğŸ’¬ FinOps AI Assistant")

left_spacer, center_col, right_spacer = st.columns([1, 2, 1])

with center_col:

    chat_container = st.container()
    render_messages(chat_container)

    user_input = st.chat_input("Ask about your cloud cost...")

    if user_input:

        add_message("user", user_input)

        with chat_container:
            st.markdown('<div class="chat-wrap">', unsafe_allow_html=True)
            st.markdown(bubble_html("user", user_input), unsafe_allow_html=True)

            # ---- Fake Thinking Steps ----
            thinking_placeholder = st.empty()
            steps = generate_thinking_steps(user_input)

            for step in steps:
                thinking_placeholder.markdown(
                    bubble_html("assistant", step),
                    unsafe_allow_html=True
                )
                time.sleep(0.8)

            # ---- Final Streaming Response ----
            reply = simple_bot_reply(user_input, temperature)

            final_placeholder = st.empty()
            buffer = ""

            for ch in reply:
                buffer += ch
                final_placeholder.markdown(
                    bubble_html("assistant", buffer),
                    unsafe_allow_html=True
                )
                time.sleep(0.01)

            st.markdown('</div>', unsafe_allow_html=True)

        add_message("assistant", reply)
        st.rerun()
def bubble_html(role: str, content: str) -> str:
    """
    Returns WhatsApp-like bubble HTML for a given role/content.
    role: "user" or "assistant"
    """
    side = "right" if role == "user" else "left"
    who  = "user" if role == "user" else "assistant"
    # We wrap content in a div with classes that CSS styles.
    # Use st.markdown(..., unsafe_allow_html=True) to render.
    return f'''
    <div class="msg-row {side}">
        <div class="bubble {who}">{content}</div>
    </div>
    '''

def render_messages(container):
    # Render all history in a stacked wrapper
    with container:
        st.markdown('<div class="chat-wrap">', unsafe_allow_html=True)
        for msg in st.session_state.messages:
            # We still get the benefit of chat avatars if you want:
            # with st.chat_message(msg["role"]): ...
            # But for pure control, we directly render bubbles:
            st.markdown(bubble_html(msg["role"], msg["content"]), unsafe_allow_html=True)
        st.markdown('</div>', unsafe_allow_html=True)

def stream_text(text, speed=0.01):
    # For streaming inside a bubble, we can still stream by updating the HTML.
    # We'll stream into a placeholder located inside a right/left msg-row.
    placeholder = st.empty()
    buf = ""
    for ch in text:
        buf += ch
        placeholder.markdown(f'''
            <div class="msg-row left">
                <div class="bubble assistant">{buf}</div>
            </div>
        ''', unsafe_allow_html=True)
        time.sleep(speed)
    return placeholder

def simple_bot_reply(user_text, temperature):
    return (
        f"**Temperature:** `{temperature}`\n\n"
        f"You said: {user_text}"
    )

# -----------------------------
# App
# -----------------------------
init_state()

# Sidebar (only temperature + clear chat)
with st.sidebar:
    st.header("âš™ï¸ Settings")

    temperature = st.slider(
        "Temperature",
        min_value=0.0,
        max_value=2.0,
        value=0.7,
        step=0.05,
        help="Lower = more deterministic, Higher = more creative"
    )

    if st.button("ğŸ§¹ Clear chat", use_container_width=True):
        st.session_state.messages = [
            {"role": "assistant", "content": "Chat cleared âœ… Start again!"}
        ]
        st.rerun()

st.title("ğŸ’¬ Chatbot")

# -----------------------------
# Centered chat layout (chat behind, floating input upfront)
# -----------------------------
left_spacer, center_col, right_spacer = st.columns([1, 2, 1])

with center_col:
    # Chat history area
    chat_container = st.container()
    render_messages(chat_container)

    # Floating input (fixed via CSS)
    user_input = st.chat_input("Type your message...")

    if user_input:
        # Persist + render user bubble on the right
        add_message("user", user_input)
        with chat_container:
            st.markdown('<div class="chat-wrap">', unsafe_allow_html=True)
            st.markdown(bubble_html("user", user_input), unsafe_allow_html=True)

            # Assistant bubble (left), streamed
            reply = simple_bot_reply(user_input, temperature=temperature)
            ph = st.empty()
            buf = ""
            for ch in reply:
                buf += ch
                ph.markdown(bubble_html("assistant", buf), unsafe_allow_html=True)
                time.sleep(0.01)  # same fixed typing speed
            st.markdown('</div>', unsafe_allow_html=True)

        add_message("assistant", reply)
        st.rerun()
